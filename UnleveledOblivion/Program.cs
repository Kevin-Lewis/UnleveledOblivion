using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Oblivion;
using Noggog;
using System.Linq;
using System.Runtime;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Newtonsoft.Json;

namespace UnleveledOblivion
{
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        public static Settings Settings => _settings.Value;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IOblivionMod, IOblivionModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Oblivion, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            OutputNPCStats(state, "_old");
            OutputCreatureStats(state, "_old");
            UpdateGameSettings(state);
            UpdateCreatureLeveledLists(state);
            UpdateCreatures(state);
            UpdateNPCs(state);
            OutputNPCStats(state, "_new");
            OutputCreatureStats(state, "_new");
        }

        public static void UpdateGameSettings(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            foreach (var gsGettor in state.LoadOrder.PriorityOrder.GameSetting().WinningOverrides().ToArray())
            {
                var setting = gsGettor.DeepCopy();
                if (setting.EditorID == "iLevCreaLevelDifferenceMax")
                {
                    setting = new GameSettingInt(setting.FormKey)
                    {
                        EditorID = "iLevCreaLevelDifferenceMax",
                        Data = 999
                    };
                    state.PatchMod.GameSettings.Set(setting);
                }
            }
        }

        public static void UpdateCreatureLeveledLists(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            foreach (var clGetter in state.LoadOrder.PriorityOrder.LeveledCreature().WinningOverrides())
            {
                // Add it to the patch
                var creatureList = state.PatchMod.LeveledCreatures.GetOrAddAsOverride(clGetter);

                // Adjust
                foreach (var entry in creatureList.Entries)
                {
                    entry.Level = 1;
                }
            }
        }

        public static void UpdateCreatures(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            var highestLevels = new Dictionary<string, (short, Creature)>();
            var regex = new Regex(@"\d+$");  // regex to match trailing numbers

            // Read the creature file and create a dictionary
            var path = Path.Combine(state.ExtraSettingsDataPath, "Creatures.json");
            string creatureLevelsJson = File.ReadAllText(path);
            var creatureLevelsFromFile = JsonConvert.DeserializeObject<List<NPCLevel>>(creatureLevelsJson)
                        .Where(creatureLevel => creatureLevel != null && !string.IsNullOrWhiteSpace(creatureLevel?.EditorID))
                        .ToDictionary(creatureLevel => creatureLevel.EditorID, level => level.Level);

            foreach (var creatureGetter in state.LoadOrder.PriorityOrder.Creature().WinningOverrides())
            {
                Creature creature = state.PatchMod.Creatures.GetOrAddAsOverride(creatureGetter) ?? throw new Exception("Could not add creature as override.");
                if (creature.Configuration is null) { continue; }

                // Adjust
                if (creature.Configuration.Flags.HasFlag(Creature.CreatureFlag.PCLevelOffset))
                {
                    creature.Configuration.Flags -= Creature.CreatureFlag.PCLevelOffset;
                    CalculateCreatureLevel(creature, state.LinkCache, isStatic: false, creatureLevelsFromFile);
                }
                else
                {
                    CalculateCreatureLevel(creature, state.LinkCache, isStatic: true, creatureLevelsFromFile);
                }

                CheckForHigherLevelVariant(creature, highestLevels, regex);
            }
        }

        public static void CalculateCreatureLevel(Creature creature, ILinkCache linkCache, bool isStatic, Dictionary<string, short> creatureLevelsFromFile)
        {
            if (creature.Configuration is null || creature.EditorID is null || creature.Name is null) { return; }

            // If the creature is in the file, use the level from the file
            if (creatureLevelsFromFile.TryGetValue(creature.EditorID, out short levelFromFile))
            {
                creature.Configuration.LevelOffset = levelFromFile;
                return;
            }

            short startingLevel = creature.Configuration.LevelOffset;
            creature.Configuration.LevelOffset = Settings.CreatureSettings.BaseLevel;
            creature.Configuration.LevelOffset += AdjustLevelOffsetBySoulType(creature);
            AdjustCreatureLevelByFaction(creature, linkCache);
            if (!isStatic)
            {
                _ = startingLevel switch
                {
                    _ when startingLevel < 0 => creature.Configuration.LevelOffset -= Settings.CreatureSettings.ScaledBelowPlayerOffset,
                    _ when startingLevel > 0 => creature.Configuration.LevelOffset += Settings.CreatureSettings.ScaledAbovePlayerOffset,
                    _ => creature.Configuration.LevelOffset += 0
                };
            }
            if (creature.Name.ToLower().Contains("goblin") || creature.Name.ToLower().Contains("grummite"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.GoblinMin);
            }
            if (creature.Name.ToLower().Contains("dog") || creature.EditorID.ToLower().Contains("dog"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.DogMin);
            }
            if (creature.Name.ToLower().Contains("wolf") || creature.EditorID.ToLower().Contains("wolf"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.WolfMin);
            }
            if (creature.Name.ToLower().Contains("horse") || creature.EditorID.ToLower().Contains("horse"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.HorseMin);
            }
            if (creature.Name.ToLower().Contains("troll") || creature.EditorID.ToLower().Contains("troll"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.TrollMin);
            }
            if (creature.Name.ToLower().Contains("zombie") || creature.EditorID.ToLower().Contains("zombie"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.ZombieMin);
            }
            if (creature.Name.ToLower().Contains("minotaur") || creature.EditorID.ToLower().Contains("minotaur"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.MinotaurMin);
            }
            if (creature.Name.ToLower().Contains("ogre") || creature.EditorID.ToLower().Contains("ogre"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.OgreMin);
            }
            if (creature.Name.ToLower().Contains("bear") || creature.EditorID.ToLower().Contains("bear"))
            {
                creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.CreatureMinSettings.BearMin);
            }
            creature.Configuration.LevelOffset = Math.Max((short)1, Math.Min((short)50, creature.Configuration.LevelOffset));
        }


        public static void CheckForHigherLevelVariant(Creature creature, Dictionary<string, (short, Creature)> highestLevels, Regex regex)
        {
            if (creature.Configuration is null || creature.EditorID is null || creature.Data  is null) { return; }
            var idWithoutNumber = regex.Replace(creature.EditorID, "");
            var compositeKey = idWithoutNumber + "_" + creature.Name;

            if (highestLevels.TryGetValue(compositeKey, out (short, Creature) previousHighest))
            {
                if (creature.Configuration.LevelOffset > previousHighest.Item1 && previousHighest.Item2.Configuration is not null && previousHighest.Item2.Data is not null)
                {
                    previousHighest.Item2.Configuration.LevelOffset = creature.Configuration.LevelOffset;
                    previousHighest.Item2.Data.SoulLevel = (SoulLevel)Math.Max((byte)creature.Data.SoulLevel, (byte)previousHighest.Item2.Data.SoulLevel);
                    highestLevels[compositeKey] = (creature.Configuration.LevelOffset, creature);
                }
                else if (previousHighest.Item2.Data is not null)
                {
                    creature.Configuration.LevelOffset = previousHighest.Item1;
                    creature.Data.SoulLevel = (SoulLevel)Math.Max((byte)creature.Data.SoulLevel, (byte)previousHighest.Item2.Data.SoulLevel);
                }
            }
            else
            {
                highestLevels[compositeKey] = (creature.Configuration.LevelOffset, creature);
            }
        }

        public static short AdjustLevelOffsetBySoulType(Creature creature)
        {
            var level = creature?.Data?.SoulLevel;
            switch (level)
            {
                case SoulLevel.None:
                    return 0;
                case SoulLevel.Petty: 
                    return Settings.CreatureSettings.SoulSettings.PettySoulOffset;
                case SoulLevel.Lesser:
                    return Settings.CreatureSettings.SoulSettings.LesserSoulOffset;
                case SoulLevel.Common:
                    return Settings.CreatureSettings.SoulSettings.CommonSoulOffset;
                case SoulLevel.Greater: 
                    return Settings.CreatureSettings.SoulSettings.GreaterSoulOffset;
                case SoulLevel.Grand:
                    return Settings.CreatureSettings.SoulSettings.GrandSoulOffset;
                default:
                    return 0;
            }
        }

        public static void AdjustCreatureLevelByFaction(Creature creature, ILinkCache linkCache)
        {
            foreach (var item in creature.Factions)
            {
                var faction = item.Faction.TryResolve(linkCache);
                if (faction is null || faction?.EditorID is null || creature?.Configuration?.LevelOffset is null) { return; }
                if (faction.EditorID == "LichFaction")
                {
                    creature.Configuration.LevelOffset = Math.Max(creature.Configuration.LevelOffset, Settings.CreatureSettings.FactionSettings.LichMin);
                }
            }
        }

        public static void UpdateNPCs(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            // Read the creature file and create a dictionary
            if (state?.ExtraSettingsDataPath is null) { return; }
            var path = Path.Combine(state.ExtraSettingsDataPath, "NPCs.json");
            string npcLevelsJson = File.ReadAllText(path);
            var npcLevelsFromFile = JsonConvert.DeserializeObject<List<NPCLevel>>(npcLevelsJson)
                        .Where(npcLevel => npcLevel != null && !string.IsNullOrWhiteSpace(npcLevel?.EditorID))
                        .ToDictionary(npcLevel => npcLevel.EditorID, npc => npc.Level);


            foreach (var npcGetter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
            {
                // Add it to the patch
                Npc npc = state.PatchMod.Npcs.GetOrAddAsOverride(npcGetter) ?? throw new Exception("Could not add npc as override.");
                // Adjust
                if (npc?.Configuration?.Flags is not null)
                {
                    if (npc.Configuration.Flags.HasFlag(Npc.NpcFlag.PCLevelOffset))
                    {
                        npc.Configuration.Flags -= Npc.NpcFlag.PCLevelOffset;
                        CalculateNPCLevel(npc, state.LinkCache, isStatic: false, npcLevelsFromFile);
                    }
                    else
                    {
                        CalculateNPCLevel(npc, state.LinkCache, isStatic: true, npcLevelsFromFile);
                    }
                    npc.Configuration.Flags |= Npc.NpcFlag.AutoCalcStats;
                }
            }
        }

        public static void CalculateNPCLevel(Npc npc, ILinkCache linkCache, bool isStatic, Dictionary<string, short> npcLevelsFromFile)
        {
            if (npc.Configuration is null || npc.EditorID is null || npc?.Name is null) { return; }

            // If the creature is in the file, use the level from the file
            if (npcLevelsFromFile.TryGetValue(npc.EditorID, out short levelFromFile))
            {
                npc.Configuration.LevelOffset = levelFromFile;
                return;
            }

            short startingLevel = npc.Configuration.LevelOffset;           
            if (npc.Name.ToLower().Contains("vampire"))
            {
                npc.Configuration.LevelOffset = Settings.NPCSettings.VampireBaseLevel;
            }
            else
            {
                npc.Configuration.LevelOffset = Settings.NPCSettings.BaseLevel;
            }
            if (npc.Configuration.Flags.HasFlag(Npc.NpcFlag.Female))
            {
                npc.Configuration.LevelOffset += Settings.NPCSettings.GenderOffset;
            }
            if (!isStatic)
            {
                _ = startingLevel switch
                {
                    _ when startingLevel < 0 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier1Offset,
                    _ when startingLevel <= 0 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier2Offset,
                    _ when startingLevel <= 1 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier3Offset,
                    _ when startingLevel <= 2 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier4Offset,
                    _ when startingLevel <= 3 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier5Offset,
                    _ when startingLevel <= 4 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier6Offset,
                    _ when startingLevel <= 5 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier7Offset,
                    _ when startingLevel <= 6 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier8Offset,
                    _ when startingLevel <= 50 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier9Offset,
                    _ => npc.Configuration.LevelOffset += 0
                };
            }
            else
            {
                _ = startingLevel switch
                {
                    _ when startingLevel <= 2 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier1Offset,
                    _ when startingLevel <= 5 => npc.Configuration.LevelOffset += 0,
                    _ when startingLevel <= 10 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier2Offset,
                    _ when startingLevel <= 17 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier3Offset,
                    _ when startingLevel <= 20 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier4Offset,
                    _ when startingLevel <= 50 => npc.Configuration.LevelOffset += Settings.NPCSettings.Tier9Offset,
                    _ => npc.Configuration.LevelOffset += 0
                };
            }

            AdjustNPCLevelByClass(npc, linkCache);
            AdjustNPCLevelByFaction(npc, linkCache);
            AdjustNPCLevelByRace(npc, linkCache);           
            npc.Configuration.LevelOffset = Math.Max((short)1, Math.Min((short)50, npc.Configuration.LevelOffset));
        }

        public static void AdjustNPCLevelByClass(Npc npc, ILinkCache linkCache)
        {
            IClassGetter? npcClass = npc.Class.TryResolve(linkCache);
            if (npcClass is null || npcClass?.EditorID is null || npc?.Configuration?.LevelOffset is null) { return; }
            if (npcClass.EditorID.ToLower().Contains("guard") || npcClass.EditorID.ToLower().Contains("soldier"))
            {
                npc.Configuration.LevelOffset = Settings.NPCSettings.ClassSettings.GuardLevel;
            }
            if (npcClass.EditorID == "Herald" || npcClass.EditorID == "Herder" 
                || npcClass.EditorID == "Commoner" || npcClass.EditorID == "Farmer" 
                || npcClass.EditorID == "Bard" || npcClass.EditorID == "Merchant")
            {
                npc.Configuration.LevelOffset += Settings.NPCSettings.ClassSettings.CommonerOffset;
            }
            if (npcClass.EditorID == "Warrior" || npcClass.EditorID.ToLower().Contains("knight")
                || npcClass.EditorID == "Crusader" || npcClass.EditorID == "Assassin"
                || npcClass.EditorID == "DBEnforcer" || npcClass.EditorID == "FGChampion"
                || npcClass.EditorID == "Blademaster" || npcClass.EditorID == "Pirate"
                || npcClass.EditorID == "Barbarian" || npcClass.EditorID == "Battlemage"
                || npcClass.EditorID == "Warlock" || npcClass.EditorID == "Witch"
                || npcClass.EditorID == "Sharpshooter" || npcClass.EditorID == "Hunter"
                || npcClass.EditorID == "Necromancer" || npcClass.EditorID == "Conjurer"
                || npcClass.EditorID == "Mage"
                || npcClass.EditorID.ToLower().Contains("mythic dawn")
                || npcClass.EditorID == "Sorcerer" || npcClass.EditorID == "Spellsword")
            {
                npc.Configuration.LevelOffset = Math.Max(Settings.NPCSettings.ClassSettings.WarriorMin, npc.Configuration.LevelOffset);
            }
            if (npcClass.EditorID == "Noble")
            {
                npc.Configuration.LevelOffset += Settings.NPCSettings.ClassSettings.NobleOffset;
            }
            if (npcClass.EditorID.ToLower().Contains("bandit") || npcClass.EditorID.ToLower().Contains("marauder") || npcClass.EditorID.ToLower().Contains("zealot"))
            {
                npc.Configuration.LevelOffset = Math.Max((short)Settings.NPCSettings.ClassSettings.BanditMin, Math.Min((short)Settings.NPCSettings.ClassSettings.BanditMax, npc.Configuration.LevelOffset));
            }
        }

        public static void AdjustNPCLevelByRace(Npc npc, ILinkCache linkCache)
        {
            IRaceGetter? npcRace = npc.Race.TryResolve(linkCache);
            if (npcRace is null || npcRace?.EditorID is null || npc?.Configuration?.LevelOffset is null) { return; }
            switch (npcRace.EditorID) 
            {
                case "Imperial":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.ImperialLevel;
                    break;
                case "Redguard":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.RedguardLevel;
                    break;
                case "DarkSeducer":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.DarkSeducerLevel;
                    break;
                case "GoldenSaint":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.GoldenSaintLevel;
                    break;
                case "Orc":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.OrcLevel;
                    break;
                case "DarkElf":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.DarkElfLevel;
                    break;
                case "Khajiit":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.KhajiitLevel;
                    break;
                case "WoodElf":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.WoodElfLevel;
                    break;
                case "Breton":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.BretonLevel;
                    break;
                case "Nord":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.NordLevel;
                    break;
                case "Argonian":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.ArgonianLevel;
                    break;
                case "Dremora":
                    npc.Configuration.LevelOffset += Settings.NPCSettings.RaceSettings.DremoraLevel;
                    break;
            }
        }

        public static void AdjustNPCLevelByFaction(Npc npc, ILinkCache linkCache)
        {
            foreach (var item in npc.Factions)
            {
                var faction = item.Faction.TryResolve(linkCache);
                if (faction is null || faction?.EditorID is null || npc?.Configuration?.LevelOffset is null) { return; }
                if (faction.EditorID == "SEOrderFaction")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.ForcesOrderMin);
                }
                if (faction.EditorID == "MythicDawn")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.MythicDawnMin);
                }
                if (faction.EditorID == "FightersGuild")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.FightersGuildMin);
                }
                if (faction.EditorID == "MagesGuild")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.MagesGuildMin);
                }
                if (faction.EditorID == "DarkBrotherhood")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.DarkBrotherhoodMin);
                }
                if (faction.EditorID == "ThievesGuild")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.DarkBrotherhoodMin);
                }
                if (faction.EditorID == "VampireFaction")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.VampireMin);
                }
                if (faction.EditorID == "NDKnightsoftheNine" || faction.EditorID == "NDOriginalKnightsFaction")
                {
                    npc.Configuration.LevelOffset = Math.Max(npc.Configuration.LevelOffset, Settings.NPCSettings.FactionSettings.KnightsNineMin);
                }
            }            
        }

        public static void OutputNPCStats(IPatcherState<IOblivionMod, IOblivionModGetter> state, string extension = "")
        {
            var level40s = new List<string>();
            var level30s = new List<string>();
            var level20s = new List<string>();
            var level10s = new List<string>();
            var level00s = new List<string>();
            var offset10Plus = new List<string>();
            var offset7Through9 = new List<string>();
            var offset5Through6 = new List<string>();
            var offset3Through4 = new List<string>();
            var offset1Through2 = new List<string>();
            var offset0 = new List<string>();
            var offsetNegative = new List<string>();
            foreach (var npcGetter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
            {
                var npc = npcGetter.DeepCopy();
                if (npc?.Configuration is not null && npc?.Name is not null &&npc?.EditorID is not null && npc?.Configuration?.LevelOffset is not null && npc?.Configuration?.Flags is not null)
                {
                    if (!npc.EditorID.ToLower().Contains("test"))
                    {
                        if (!(npc.Configuration.Flags.HasFlag(Npc.NpcFlag.PCLevelOffset)))
                        {
                            if (npc.Configuration.LevelOffset >= 40)
                            {
                                level40s.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 30)
                            {
                                level30s.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 20)
                            {
                                level20s.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 10)
                            {
                                level10s.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else
                            {
                                level00s.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                        }
                        else
                        {
                            if (npc.Configuration.LevelOffset >= 10)
                            {
                                offset10Plus.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 7)
                            {
                                offset7Through9.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 5)
                            {
                                offset5Through6.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 3)
                            {
                                offset3Through4.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 1)
                            {
                                offset1Through2.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else if (npc.Configuration.LevelOffset >= 0)
                            {
                                offset0.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                            else
                            {
                                offsetNegative.Add($"{npc.Name}:{npc.EditorID}:{npc.Configuration.LevelOffset}");
                            }
                        }
                    }
                }               
            }

            string downloadsFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads");

            // Write lists to files in the Downloads directory
            File.WriteAllLines(Path.Combine(downloadsFolder, $"level40s{extension}.txt"), level40s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"level30s{extension}.txt"), level30s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"level20s{extension}.txt"), level20s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"level10s{extension}.txt"), level10s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"level00s{extension}.txt"), level00s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset10Plus{extension}.txt"), offset10Plus.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset7Through9{extension}.txt"), offset7Through9.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset5Through6{extension}.txt"), offset5Through6.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset3Through4{extension}.txt"), offset3Through4.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset1Through2{extension}.txt"), offset1Through2.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offset0{extension}.txt"), offset0.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"offsetNegative{extension}.txt"), offsetNegative.OrderByDescending(x => short.Parse(x.Split(":")[2])));

        }

        public static void OutputCreatureStats(IPatcherState<IOblivionMod, IOblivionModGetter> state, string extension = "")
        {
            var level40s = new List<string>();
            var level30s = new List<string>();
            var level20s = new List<string>();
            var level10s = new List<string>();
            var level00s = new List<string>();
            var offset10Plus = new List<string>();
            var offset7Through9 = new List<string>();
            var offset5Through6 = new List<string>();
            var offset3Through4 = new List<string>();
            var offset1Through2 = new List<string>();
            var offset0 = new List<string>();
            var offsetNegative = new List<string>();
            foreach (var creatureGetter in state.LoadOrder.PriorityOrder.Creature().WinningOverrides())
            {
                var creature = creatureGetter.DeepCopy();
                if (creature?.Configuration is not null && creature?.Name is not null && creature?.EditorID is not null && creature?.Configuration?.LevelOffset is not null && creature?.Configuration?.Flags is not null)
                {
                    if (!creature.EditorID.ToLower().Contains("test"))
                    {
                        if (!(creature.Configuration.Flags.HasFlag(Creature.CreatureFlag.PCLevelOffset)))
                        {
                            if (creature.Configuration.LevelOffset >= 40)
                            {
                                level40s.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 30)
                            {
                                level30s.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 20)
                            {
                                level20s.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 10)
                            {
                                level10s.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else
                            {
                                level00s.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                        }
                        else
                        {
                            if (creature.Configuration.LevelOffset >= 10)
                            {
                                offset10Plus.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 7)
                            {
                                offset7Through9.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 5)
                            {
                                offset5Through6.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 3)
                            {
                                offset3Through4.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 1)
                            {
                                offset1Through2.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else if (creature.Configuration.LevelOffset >= 0)
                            {
                                offset0.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                            else
                            {
                                offsetNegative.Add($"{creature.Name}:{creature.EditorID}:{creature.Configuration.LevelOffset}");
                            }
                        }
                    }
                }
            }

            string downloadsFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads");

            // Write lists to files in the Downloads directory
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_level40s{extension}.txt"), level40s.OrderByDescending(x => short.Parse(x.Split(":")[2])));               
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_level30s{extension}.txt"), level30s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_level20s{extension}.txt"), level20s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_level10s{extension}.txt"), level10s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_level00s{extension}.txt"), level00s.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset10Plus{extension}.txt"), offset10Plus.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset7Through9{extension}.txt"), offset7Through9.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset5Through6{extension}.txt"), offset5Through6.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset3Through4{extension}.txt"), offset3Through4.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset1Through2{extension}.txt"), offset1Through2.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offset0{extension}.txt"), offset0.OrderByDescending(x => short.Parse(x.Split(":")[2])));
            File.WriteAllLines(Path.Combine(downloadsFolder, $"c_offsetNegative{extension}.txt"), offsetNegative.OrderByDescending(x => short.Parse(x.Split(":")[2])));

        }
    }
}
